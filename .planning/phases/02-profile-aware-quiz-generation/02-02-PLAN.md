---
phase: 02-profile-aware-quiz-generation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - types.ts
  - hooks/useQuizSession.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Quiz detects fatigue when child answers too fast AND accuracy drops"
    - "Quiz triggers frustration circuit breaker after 3 consecutive wrong answers on same topic"
    - "Fatigue detection only activates after minimum 5 questions"
    - "Silent topic switching happens on frustration (child doesn't see explanation)"
    - "Quiz ends early with encouraging message when fatigue or frustration thresholds met"
  artifacts:
    - path: "types.ts"
      provides: "FatigueState, FrustrationState interfaces"
      contains: "FatigueState"
    - path: "hooks/useQuizSession.ts"
      provides: "Fatigue and frustration tracking state and handlers"
      contains: "fatigueState"
  key_links:
    - from: "hooks/useQuizSession.ts"
      to: "lib/encouragement.ts"
      via: "getEncouragementMessage import"
      pattern: "import.*getEncouragementMessage.*from"
    - from: "hooks/useQuizSession.ts"
      to: "types.ts"
      via: "FatigueState, FrustrationState imports"
      pattern: "import.*FatigueState.*from"
---

<objective>
Add fatigue detection and frustration circuit breaker to useQuizSession hook

Purpose: Make quizzes child-friendly by detecting cognitive fatigue and topic-specific frustration, ending quizzes early with encouragement
Output: Extended useQuizSession hook with adaptive early-ending capabilities
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-profile-aware-quiz-generation/02-RESEARCH.md

# Existing hook we're extending
@hooks/useQuizSession.ts
@types.ts
@lib/encouragement.ts (created in 02-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fatigue and frustration state types</name>
  <files>types.ts</files>
  <action>
Add new interfaces after the ADAPTIVE QUIZ TYPES section (after QuestionRequest, around line 375):

```typescript
/**
 * State for fatigue detection during quiz session
 * Tracks answer speed and recent accuracy to detect cognitive fatigue
 */
export interface FatigueState {
  /** Baseline average answer time from first 5 questions (seconds) */
  averageAnswerTime: number;
  /** Rolling window of last 3 answer times (seconds) */
  recentAnswerTimes: number[];
  /** Rolling window of last 5 answer correctness */
  recentAccuracy: boolean[];
  /** Whether fatigue has been detected */
  fatigueDetected: boolean;
}

/**
 * State for frustration circuit breaker during quiz
 * Tracks consecutive errors per topic to prevent frustration spirals
 */
export interface FrustrationState {
  /** Consecutive error count by topic */
  consecutiveErrorsByTopic: Record<string, number>;
  /** Topics currently blocked due to frustration threshold */
  blockedTopics: Set<string>;
  /** Last topic answered (for silent switching) */
  lastTopic: string;
  /** Questions answered since last block (for cooldown) */
  questionsSinceBlock: number;
}

/**
 * Constants for adaptive quiz behavior
 */
export const ADAPTIVE_QUIZ_CONSTANTS = {
  /** Minimum questions before fatigue detection activates */
  FATIGUE_MIN_QUESTIONS: 5,
  /** Speed threshold: recent avg < baseline * this = rushing */
  FATIGUE_SPEED_THRESHOLD: 0.5,
  /** Accuracy threshold: recent < this = struggling */
  FATIGUE_ACCURACY_THRESHOLD: 0.4,
  /** Consecutive errors on same topic to trigger circuit breaker */
  FRUSTRATION_THRESHOLD: 3,
  /** Questions to wait before unblocking topics */
  COOLDOWN_QUESTIONS: 3
} as const;
```

These types enable type-safe adaptive quiz state management.
  </action>
  <verify>
Run `npx tsc --noEmit` - should pass.
Verify FatigueState and FrustrationState interfaces exist in types.ts.
  </verify>
  <done>
FatigueState and FrustrationState interfaces are defined in types.ts.
ADAPTIVE_QUIZ_CONSTANTS provides configurable thresholds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend useQuizSession with fatigue and frustration tracking</name>
  <files>hooks/useQuizSession.ts</files>
  <action>
Extend the useQuizSession hook to track and respond to fatigue and frustration:

1. Add imports at top of file:
```typescript
import {
  QuizQuestion,
  ChildProfile,
  Subject,
  UpcomingTest,
  DifficultyLevel,
  FatigueState,
  FrustrationState,
  ADAPTIVE_QUIZ_CONSTANTS
} from '../types';
import { getEncouragementMessage, logger, getUserMessage } from '../lib';
```

2. Add new state and return types to existing interfaces:

In `QuizSessionState` interface (around line 14), add:
```typescript
  /** Message shown when quiz ends early due to fatigue */
  fatigueEndMessage: string | null;
  /** Message shown when quiz ends early due to frustration */
  frustrationEndMessage: string | null;
  /** End reason for analytics */
  earlyEndReason: 'fatigue' | 'frustration' | null;
```

In `UseQuizSessionReturn` interface (around line 65), add:
```typescript
  /** Fatigue tracking state (for analytics) */
  fatigueState: FatigueState;
  /** Frustration tracking state (for analytics) */
  frustrationState: FrustrationState;
```

3. Inside the `useQuizSession` function, after existing state declarations (around line 128), add:

```typescript
  // Adaptive quiz state
  const [fatigueEndMessage, setFatigueEndMessage] = useState<string | null>(null);
  const [frustrationEndMessage, setFrustrationEndMessage] = useState<string | null>(null);
  const [earlyEndReason, setEarlyEndReason] = useState<'fatigue' | 'frustration' | null>(null);

  // Fatigue tracking
  const [fatigueState, setFatigueState] = useState<FatigueState>({
    averageAnswerTime: 0,
    recentAnswerTimes: [],
    recentAccuracy: [],
    fatigueDetected: false
  });

  // Frustration tracking
  const [frustrationState, setFrustrationState] = useState<FrustrationState>({
    consecutiveErrorsByTopic: {},
    blockedTopics: new Set(),
    lastTopic: '',
    questionsSinceBlock: 0
  });

  // Answer timing
  const [answerStartTime, setAnswerStartTime] = useState<number>(Date.now());
```

4. Add helper functions BEFORE the handleAnswer callback:

```typescript
  /**
   * Detect fatigue based on speed AND accuracy drop
   * Both conditions must be true to avoid false positives (smart fast kids)
   */
  const detectFatigue = useCallback((state: FatigueState): boolean => {
    const { FATIGUE_MIN_QUESTIONS, FATIGUE_SPEED_THRESHOLD, FATIGUE_ACCURACY_THRESHOLD } = ADAPTIVE_QUIZ_CONSTANTS;

    // Need minimum data
    if (state.recentAnswerTimes.length < 3) return false;
    if (state.recentAccuracy.length < 5) return false;

    // Check if rushing (answering < 50% of baseline time)
    const recentAvg = state.recentAnswerTimes.reduce((a, b) => a + b, 0) / state.recentAnswerTimes.length;
    const isRushing = state.averageAnswerTime > 0 && recentAvg < state.averageAnswerTime * FATIGUE_SPEED_THRESHOLD;

    // Check accuracy drop (< 40% correct in last 5)
    const correctCount = state.recentAccuracy.filter(Boolean).length;
    const recentAccuracyRate = correctCount / state.recentAccuracy.length;
    const hasAccuracyDrop = recentAccuracyRate < FATIGUE_ACCURACY_THRESHOLD;

    // Fatigue = both rushing AND poor accuracy
    return isRushing && hasAccuracyDrop;
  }, []);

  /**
   * Update fatigue state after each answer
   */
  const updateFatigueState = useCallback((
    currentState: FatigueState,
    answerTime: number,
    isCorrect: boolean,
    questionIndex: number
  ): FatigueState => {
    const { FATIGUE_MIN_QUESTIONS } = ADAPTIVE_QUIZ_CONSTANTS;

    // First 5 questions establish baseline
    if (questionIndex < FATIGUE_MIN_QUESTIONS) {
      const newAvg = (currentState.averageAnswerTime * questionIndex + answerTime) / (questionIndex + 1);
      return {
        ...currentState,
        averageAnswerTime: newAvg,
        recentAnswerTimes: [],
        recentAccuracy: [],
        fatigueDetected: false
      };
    }

    // After 5 questions, start monitoring
    const newRecentTimes = [...currentState.recentAnswerTimes, answerTime];
    if (newRecentTimes.length > 3) newRecentTimes.shift();

    const newRecentAccuracy = [...currentState.recentAccuracy, isCorrect];
    if (newRecentAccuracy.length > 5) newRecentAccuracy.shift();

    const updatedState: FatigueState = {
      ...currentState,
      recentAnswerTimes: newRecentTimes,
      recentAccuracy: newRecentAccuracy,
      fatigueDetected: false
    };

    return {
      ...updatedState,
      fatigueDetected: detectFatigue(updatedState)
    };
  }, [detectFatigue]);

  /**
   * Update frustration state after each answer
   */
  const updateFrustrationState = useCallback((
    currentState: FrustrationState,
    topic: string,
    isCorrect: boolean
  ): FrustrationState => {
    const { FRUSTRATION_THRESHOLD } = ADAPTIVE_QUIZ_CONSTANTS;
    const currentCount = currentState.consecutiveErrorsByTopic[topic] || 0;

    if (isCorrect) {
      // Reset counter on correct answer
      return {
        ...currentState,
        consecutiveErrorsByTopic: {
          ...currentState.consecutiveErrorsByTopic,
          [topic]: 0
        },
        lastTopic: topic,
        questionsSinceBlock: currentState.blockedTopics.size > 0
          ? currentState.questionsSinceBlock + 1
          : 0
      };
    }

    // Increment error count
    const newCount = currentCount + 1;
    const newConsecutive = {
      ...currentState.consecutiveErrorsByTopic,
      [topic]: newCount
    };

    // Check if threshold reached
    if (newCount >= FRUSTRATION_THRESHOLD) {
      logger.warn('useQuizSession: Frustration detected on topic', {
        topic,
        consecutiveErrors: newCount
      });

      return {
        ...currentState,
        consecutiveErrorsByTopic: newConsecutive,
        blockedTopics: new Set([...currentState.blockedTopics, topic]),
        lastTopic: topic,
        questionsSinceBlock: 0
      };
    }

    return {
      ...currentState,
      consecutiveErrorsByTopic: newConsecutive,
      lastTopic: topic,
      questionsSinceBlock: currentState.blockedTopics.size > 0
        ? currentState.questionsSinceBlock + 1
        : 0
    };
  }, []);

  /**
   * Apply cooldown to unblock topics after waiting period
   */
  const applyCooldown = useCallback((state: FrustrationState): FrustrationState => {
    const { COOLDOWN_QUESTIONS } = ADAPTIVE_QUIZ_CONSTANTS;

    if (state.questionsSinceBlock >= COOLDOWN_QUESTIONS && state.blockedTopics.size > 0) {
      logger.info('useQuizSession: Cooldown complete, unblocking topics');
      return {
        ...state,
        blockedTopics: new Set(),
        consecutiveErrorsByTopic: {},
        questionsSinceBlock: 0
      };
    }
    return state;
  }, []);
```

5. Reset answer start time when question changes. Add this useEffect after existing state:

```typescript
  // Reset answer timer when question changes
  useEffect(() => {
    setAnswerStartTime(Date.now());
  }, [currentIndex]);
```

6. Modify the `handleAnswer` callback to include adaptive tracking. Replace the existing handleAnswer with:

```typescript
  // Handle answer selection with adaptive tracking
  const handleAnswer = useCallback((optionIndex: number) => {
    if (isAnswered || questions.length === 0) return;

    const answerTime = (Date.now() - answerStartTime) / 1000; // Seconds
    const currentQ = questions[currentIndex];
    const isCorrect = optionIndex === currentQ.correctAnswerIndex;
    const topic = currentQ.topic || topic; // Use question topic or session topic

    setSelectedOption(optionIndex);
    setIsAnswered(true);

    // Record answer
    setUserAnswers(prev => {
      const newAnswers = [...prev];
      newAnswers[currentIndex] = optionIndex;
      return newAnswers;
    });

    // Update score if correct
    if (isCorrect) {
      setScore(s => s + 1);
    }

    // Update fatigue tracking
    const newFatigueState = updateFatigueState(fatigueState, answerTime, isCorrect, currentIndex);
    setFatigueState(newFatigueState);

    // Check fatigue and end early if detected
    if (newFatigueState.fatigueDetected && currentIndex >= ADAPTIVE_QUIZ_CONSTANTS.FATIGUE_MIN_QUESTIONS) {
      logger.info('useQuizSession: Fatigue detected, ending early', {
        questionIndex: currentIndex,
        avgTime: newFatigueState.averageAnswerTime,
        recentTimes: newFatigueState.recentAnswerTimes
      });
      setFatigueEndMessage(getEncouragementMessage('fatigue'));
      setEarlyEndReason('fatigue');
      setIsFinished(true);
      return;
    }

    // Update frustration tracking
    let newFrustrationState = updateFrustrationState(frustrationState, topic, isCorrect);
    newFrustrationState = applyCooldown(newFrustrationState);
    setFrustrationState(newFrustrationState);

    // Check if all topics blocked (end quiz)
    // Only check on last question or if we have multiple topics
    const uniqueTopics = new Set(questions.map(q => q.topic || '')).size;
    if (newFrustrationState.blockedTopics.size > 0 && newFrustrationState.blockedTopics.size >= uniqueTopics) {
      logger.info('useQuizSession: All topics blocked by frustration, ending early');
      setFrustrationEndMessage(getEncouragementMessage('frustration'));
      setEarlyEndReason('frustration');
      setIsFinished(true);
      return;
    }
  }, [
    isAnswered,
    questions,
    currentIndex,
    answerStartTime,
    topic,
    fatigueState,
    frustrationState,
    updateFatigueState,
    updateFrustrationState,
    applyCooldown
  ]);
```

Note: There's a variable shadowing issue with `topic` - use `currentQ.topic || options.topic` to get the right topic. Check the original code for the exact variable name.

7. Update the return statement to include new state (around line 348):

Add to return object:
```typescript
    // Early end messages
    fatigueEndMessage,
    frustrationEndMessage,
    earlyEndReason,

    // Adaptive state (for analytics)
    fatigueState,
    frustrationState,
```
  </action>
  <verify>
Run `npx tsc --noEmit` - should pass.
Verify useQuizSession hook exports fatigueState and frustrationState.
Check that getEncouragementMessage is imported from lib.
  </verify>
  <done>
useQuizSession hook tracks fatigue and frustration state.
Quiz ends early with encouraging Hebrew message when thresholds are met.
Fatigue requires BOTH rushing AND accuracy drop (no false positives for fast learners).
Frustration circuit breaker tracks per-topic consecutive errors.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit` passes
2. FatigueState and FrustrationState types exist in types.ts
3. useQuizSession exports fatigueState, frustrationState, fatigueEndMessage, frustrationEndMessage
4. getEncouragementMessage is imported and used for early end messages
5. Fatigue detection requires both speed drop AND accuracy drop
6. Frustration tracking is per-topic (not global)
</verification>

<success_criteria>
- [ ] FatigueState interface tracks averageAnswerTime, recentAnswerTimes, recentAccuracy, fatigueDetected
- [ ] FrustrationState interface tracks consecutiveErrorsByTopic, blockedTopics, lastTopic
- [ ] ADAPTIVE_QUIZ_CONSTANTS provides configurable thresholds
- [ ] handleAnswer calculates answer time and updates both fatigue and frustration state
- [ ] Fatigue triggers only when BOTH rushing (<50% baseline speed) AND accuracy drop (<40% correct)
- [ ] Frustration triggers after 3 consecutive wrong answers on SAME topic
- [ ] Quiz ends early with Hebrew encouragement message from lib/encouragement.ts
- [ ] All new code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-profile-aware-quiz-generation/02-02-SUMMARY.md`
</output>
