---
phase: 02-profile-aware-quiz-generation
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - services/geminiService.ts
  - hooks/useQuizSession.ts
  - hooks/index.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Child with 80% topic mastery receives harder questions than child with 40% mastery"
    - "Quiz questions include topic field for tracking"
    - "Gemini prompt includes mastery percentage and target difficulty for each question"
    - "Profile-aware quiz generation uses difficulty mixing from adaptiveQuizService"
    - "Graceful fallback to static quiz if profile unavailable"
    - "Profile is updated with quiz results after session completion (ADAPT-02)"
  artifacts:
    - path: "services/geminiService.ts"
      provides: "generateProfileAwareQuestions function"
      exports: ["generateProfileAwareQuestions"]
    - path: "hooks/useQuizSession.ts"
      provides: "Profile-aware question loading with difficulty mixing"
      contains: "classifyTopics"
  key_links:
    - from: "hooks/useQuizSession.ts"
      to: "services/adaptiveQuizService.ts"
      via: "classifyTopics, mixDifficulty, orderTopics imports"
      pattern: "import.*classifyTopics.*from"
    - from: "hooks/useQuizSession.ts"
      to: "services/geminiService.ts"
      via: "generateProfileAwareQuestions call"
      pattern: "generateProfileAwareQuestions"
---

<objective>
Create profile-aware question generation and wire adaptive quiz flow together

Purpose: Complete the adaptive quiz loop by connecting learner profile data to Gemini question generation with difficulty mixing
Output: Full profile-aware quiz generation that adapts to each child's mastery levels
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-profile-aware-quiz-generation/02-RESEARCH.md

# Dependencies from prior plans
@.planning/phases/02-profile-aware-quiz-generation/02-01-PLAN.md
@.planning/phases/02-profile-aware-quiz-generation/02-02-PLAN.md

# Files to modify
@services/geminiService.ts
@hooks/useQuizSession.ts
@hooks/useLearnerProfile.ts (for reference)
@types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add generateProfileAwareQuestions to Gemini service</name>
  <files>services/geminiService.ts</files>
  <action>
Add a new function to geminiService.ts for profile-aware question generation. Add after the existing `generateQuizQuestions` function (around line 156):

```typescript
/**
 * Generate profile-aware quiz questions using Gemini AI
 *
 * Enhanced version that accepts per-question mastery data and target difficulty.
 * Used by adaptive quiz flow to generate questions tailored to learner profile.
 *
 * @param subject - Subject name in Hebrew
 * @param requests - Array of QuestionRequest with topic, mastery, and difficulty
 * @param grade - Child's grade level
 *
 * @throws {QuizGenerationError} If question generation fails after retries
 *
 * @example
 * const questions = await generateProfileAwareQuestions('מתמטיקה', [
 *   { topic: 'שברים', masteryPercentage: 85, targetDifficulty: 'easy' },
 *   { topic: 'כפל', masteryPercentage: 30, targetDifficulty: 'easy' }
 * ], GradeLevel.Grade4);
 */
export async function generateProfileAwareQuestions(
  subject: string,
  requests: QuestionRequest[],
  grade: GradeLevel
): Promise<QuizQuestion[]> {
  if (!hasApiKey()) {
    logger.error('generateProfileAwareQuestions: API key not configured');
    throw new QuizGenerationError('API key not configured');
  }

  if (requests.length === 0) {
    logger.warn('generateProfileAwareQuestions: No requests provided');
    return [];
  }

  const totalQuestions = requests.length;

  // Build per-question context with mastery data
  const topicContext = requests
    .map((req, idx) => {
      const masteryDesc = req.masteryPercentage < 40 ? 'struggling'
        : req.masteryPercentage < 70 ? 'learning'
        : 'proficient';

      return `Question ${idx + 1}: Topic "${req.topic}", Student Mastery: ${req.masteryPercentage}% (${masteryDesc}), Target Difficulty: ${req.targetDifficulty.toUpperCase()}`;
    })
    .join('\n');

  const prompt = `Generate ${totalQuestions} multiple-choice questions in Hebrew (עברית) for a student in ${grade}.
Subject: ${subject}

ADAPTIVE DIFFICULTY INSTRUCTIONS:
${topicContext}

For each question:
1. Use the specified topic and target difficulty
2. Consider student's mastery level when crafting the question:
   - Low mastery (0-40%): Use multiple choice with clear options, simple language, scaffolding
   - Medium mastery (40-70%): Standard curriculum level, moderate complexity
   - High mastery (70-100%): Include critical thinking, multi-step problems

3. Difficulty calibration:
   - EASY: Basic recall, definitions, straightforward calculations
   - MEDIUM: Application, combining concepts, standard curriculum
   - HARD: Analysis, synthesis, multi-step reasoning

IMPORTANT FOR MATH (${subject}):
- Format questionText as clear equation (e.g., "25 + 15 = ?")
- Use standard symbols (+, -, x, /, =)
- Minimize wordy narratives unless word problems

Make the questions age-appropriate for ${grade}.
Ensure exactly one correct answer per question.
Provide short encouraging explanation in Hebrew.
Provide helpful hint (tip) without revealing answer.

Important: The output JSON must be valid. All text in Hebrew.
CRITICAL: Each question MUST include the "topic" field matching the requested topic.`;

  logger.info('generateProfileAwareQuestions: Starting generation', {
    subject,
    grade,
    questionCount: totalQuestions,
    topics: requests.map(r => r.topic)
  });

  return retry(async () => {
    const response = await ai.models.generateContent({
      model: 'gemini-2.0-flash',
      contents: prompt,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              questionText: { type: Type.STRING, description: "The question prompt in Hebrew" },
              options: {
                type: Type.ARRAY,
                items: { type: Type.STRING },
                description: "Array of 4 possible answers in Hebrew"
              },
              correctAnswerIndex: { type: Type.INTEGER, description: "Index (0-3) of the correct answer" },
              explanation: { type: Type.STRING, description: "Short explanation in Hebrew" },
              tip: { type: Type.STRING, description: "Helpful hint without revealing answer" },
              difficulty: { type: Type.STRING, enum: ["easy", "medium", "hard"] },
              topic: { type: Type.STRING, description: "The topic this question covers" }
            },
            required: ["questionText", "options", "correctAnswerIndex", "explanation", "difficulty", "topic"]
          }
        }
      }
    });

    if (!response.text) {
      throw new QuizGenerationError('Empty response from Gemini API');
    }

    const questions = JSON.parse(response.text) as QuizQuestion[];

    if (!Array.isArray(questions) || questions.length === 0) {
      throw new QuizGenerationError('Invalid response format: expected non-empty array');
    }

    // Validate that topics are included (fallback to request topic if missing)
    const validatedQuestions = questions.map((q, idx) => ({
      ...q,
      topic: q.topic || requests[idx]?.topic || subject
    }));

    logger.info('generateProfileAwareQuestions: Successfully generated questions', {
      count: validatedQuestions.length,
      topics: validatedQuestions.map(q => q.topic)
    });

    return validatedQuestions;
  }, {
    ...AI_RETRY_OPTIONS,
    context: 'generateProfileAwareQuestions'
  }).catch((error) => {
    if (error instanceof QuizGenerationError) {
      throw error;
    }
    logger.error('generateProfileAwareQuestions: Failed after retries', { subject }, error);
    throw new QuizGenerationError(
      `Failed to generate profile-aware questions: ${error instanceof Error ? error.message : 'Unknown error'}`,
      { cause: error instanceof Error ? error : undefined }
    );
  });
}
```

Also add the QuestionRequest import at the top of the file:
```typescript
import {
  GradeLevel,
  QuizQuestion,
  DifficultyLevel,
  Subject,
  EvaluationType,
  ExtractedSkill,
  ExtractedQuestion,
  proficiencyToDifficulty,
  QuestionRequest  // Add this
} from "../types";
```

And extend QuizQuestion type to include optional topic field. The QuizQuestion interface is at approximately **line 112** in types.ts (in the QUIZ & SESSION TYPES section, BEFORE the LEARNER PROFILE TYPES section added by Phase 1):

```typescript
// In types.ts QuizQuestion interface (around line 112, in QUIZ & SESSION TYPES section), add topic field:
export interface QuizQuestion {
  questionText: string;
  options: string[];
  correctAnswerIndex: number;
  explanation: string;
  tip?: string;
  difficulty: DifficultyLevel;
  audioText?: string;
  topic?: string;  // ADD THIS LINE - Topic for tracking (used by adaptive quiz frustration detection)
}
```

**Location clarification:** This is in the original QuizQuestion interface, NOT in the LEARNER PROFILE or ADAPTIVE QUIZ sections added by Phase 1/02-01.
  </action>
  <verify>
Run `npx tsc --noEmit` - should pass.
Verify generateProfileAwareQuestions is exported from services/geminiService.ts.
Check that QuizQuestion includes optional topic field.
  </verify>
  <done>
generateProfileAwareQuestions function generates questions with per-topic mastery data.
Gemini prompt includes mastery percentage and target difficulty for each question.
Questions include topic field for frustration tracking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire profile-aware generation into useQuizSession</name>
  <files>hooks/useQuizSession.ts</files>
  <action>
Modify useQuizSession to use profile data for adaptive question generation.

1. Add new imports at top of file:
```typescript
import {
  generateQuizQuestions,
  generateExamRecommendations,
  analyzeMistakesAndGenerateTopics,
  generateProfileAwareQuestions  // Add this
} from '../services/geminiService';
import {
  classifyTopics,
  mixDifficulty,
  orderTopics,
  hasProfileData
} from '../services/adaptiveQuizService';
```

2. Add profile to UseQuizSessionOptions interface (around line 46):
```typescript
export interface UseQuizSessionOptions {
  child: ChildProfile;
  subject: Subject;
  topic: string;
  upcomingTests: UpcomingTest[];
  isFinalReview: boolean;
  /** Learner profile for adaptive quiz (optional - falls back to static) */
  profile?: LearnerProfile | null;
  // ... rest of existing options
}
```

3. Add LearnerProfile to imports:
```typescript
import {
  QuizQuestion,
  ChildProfile,
  Subject,
  UpcomingTest,
  DifficultyLevel,
  FatigueState,
  FrustrationState,
  ADAPTIVE_QUIZ_CONSTANTS,
  LearnerProfile,        // Add this
  QuestionRequest,       // Add this
  TopicClassification,   // Add this
  DifficultyMix          // Add this
} from '../types';
```

4. In the useQuizSession function, extract profile from options:
```typescript
const {
  child,
  subject,
  topic,
  upcomingTests,
  isFinalReview,
  profile,  // Add this
  onSessionSave,
  onAddRemediationTest
} = options;
```

5. Replace the loadQuestions function with adaptive-aware version. Find the existing loadQuestions (around line 145) and replace with:

```typescript
  // Load questions - adaptive if profile available, static otherwise
  const loadQuestions = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    const relevantTest = findRelevantTest();
    const targetTopics = isFinalReview && relevantTest
      ? relevantTest.topics
      : [topic];

    // Handle Dictation (local generation) - unchanged
    if (relevantTest?.type === 'dictation' && relevantTest.dictationWords) {
      const generated = generateDictationQuestions(
        relevantTest.dictationWords,
        relevantTest.dictationMode
      );
      setQuestions(generated);
      setIsLoading(false);
      logger.info('useQuizSession: Dictation questions loaded', {
        count: generated.length
      });
      return;
    }

    // Determine question count
    const count = isFinalReview ? 10 : (relevantTest?.numQuestions || 5);
    const fallbackDifficulty: DifficultyLevel = child.proficiency?.[subject.id] || 'medium';

    try {
      let data: QuizQuestion[];

      // Check if we should use adaptive generation
      const useAdaptive = hasProfileData(profile) && !isFinalReview;

      if (useAdaptive && profile) {
        // Adaptive generation with profile data
        logger.info('useQuizSession: Using adaptive question generation', {
          childId: child.id,
          topicCount: Object.keys(profile.topicMastery).length
        });

        // Get available topics (from subject or just the session topic)
        const availableTopics = subject.topics?.length > 0 ? subject.topics : targetTopics;

        // Classify topics by mastery level
        const classification = classifyTopics(profile, availableTopics);
        logger.info('useQuizSession: Topic classification', {
          weak: classification.weak.length,
          learning: classification.learning.length,
          mastered: classification.mastered.length
        });

        // Apply difficulty mixing (20/50/30 ratio)
        const mix = mixDifficulty(classification, count, true);
        logger.info('useQuizSession: Difficulty mix', {
          review: mix.reviewTopics.length,
          target: mix.targetTopics.length,
          weak: mix.weakTopics.length,
          total: mix.questionCount
        });

        // Order topics (easy to hard)
        const orderedTopics = orderTopics(mix);

        // Build question requests with mastery data
        const requests: QuestionRequest[] = orderedTopics.map(topicName => {
          const mastery = profile.topicMastery[topicName];
          const pKnown = mastery?.pKnown ?? 0.5;
          const masteryPercentage = Math.round(pKnown * 100);

          // Determine target difficulty based on topic category
          let targetDifficulty: DifficultyLevel;
          if (mix.weakTopics.includes(topicName)) {
            // Weak topics get easy questions (scaffolding)
            targetDifficulty = 'easy';
          } else if (mix.reviewTopics.includes(topicName)) {
            // Mastered topics get easy questions (review)
            targetDifficulty = 'easy';
          } else {
            // Learning topics get medium difficulty
            targetDifficulty = 'medium';
          }

          return { topic: topicName, masteryPercentage, targetDifficulty };
        });

        // Generate profile-aware questions
        data = await generateProfileAwareQuestions(subject.name, requests, child.grade);

        logger.info('useQuizSession: Adaptive questions loaded', {
          childId: child.id,
          count: data.length,
          topics: data.map(q => q.topic)
        });
      } else {
        // Fallback: Static generation (existing behavior)
        logger.info('useQuizSession: Using static question generation', {
          childId: child.id,
          reason: !profile ? 'no profile' : 'final review mode'
        });

        const topicPrompt = isFinalReview ? targetTopics.join(', ') : topic;
        data = await generateQuizQuestions(
          subject.name,
          topicPrompt,
          child.grade,
          count,
          fallbackDifficulty
        );

        // Add topic to questions for tracking (using session topic)
        data = data.map(q => ({
          ...q,
          topic: q.topic || topic
        }));

        logger.info('useQuizSession: Static questions loaded', {
          childId: child.id,
          count: data.length
        });
      }

      setQuestions(data);
    } catch (err) {
      const message = getUserMessage(err);
      setError(message);
      logger.error('useQuizSession: Failed to load questions', {
        childId: child.id,
        subject: subject.name,
        adaptive: hasProfileData(profile)
      }, err);
    } finally {
      setIsLoading(false);
    }
  }, [child, subject, topic, isFinalReview, findRelevantTest, profile]);
```

6. Also update the handleAnswer callback to use question's topic field. Find where `topic` is used in handleAnswer and change to:
```typescript
const questionTopic = currentQ.topic || topic; // Use question's topic or session topic
```

Then use `questionTopic` instead of `topic` in the frustration tracking call.

7. **ADAPT-02 Profile Update Integration:** Verify that session completion triggers profile learning.

The Phase 1 implementation already handles this via fire-and-forget pattern:
- When quiz completes, `finishSession` calls `onSessionSave(session)`
- The calling page (QuizSession.tsx) passes `addSession` from store.tsx
- `addSession` in store.tsx saves session AND calls `processQuizSignal` to update the learner profile

**Verification steps:**
- Check that QuizSession.tsx passes `addSession` from `useStore()` to `useQuizSession`
- Confirm `addSession` in store.tsx calls `processQuizSignal(session)` after saving
- No new code needed - just verify the existing wiring works with adaptive quiz flow

If `processQuizSignal` is NOT called in `addSession`, add it:
```typescript
// In store.tsx addSession function, after session is saved:
try {
  await processQuizSignal(session);
} catch (error) {
  // Fire-and-forget: log but don't block
  console.error('Profile update failed (non-blocking):', error);
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` - should pass.
Check that useQuizSession imports classifyTopics, mixDifficulty, generateProfileAwareQuestions.
Verify profile is an optional parameter in UseQuizSessionOptions.
  </verify>
  <done>
useQuizSession uses learner profile for adaptive question generation.
Difficulty mixing applies 20/50/30 ratio based on topic mastery levels.
Graceful fallback to static generation when profile unavailable or final review.
Questions include topic field for frustration tracking.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update hooks export and add integration test scenario</name>
  <files>hooks/index.ts</files>
  <action>
Verify hooks/index.ts exports all required types. It should already export useQuizSession, but verify the types are exported:

Check that hooks/index.ts includes:
```typescript
export { useQuizSession } from './useQuizSession';
export type {
  QuizSessionState,
  FinalReviewState,
  UseQuizSessionOptions,
  UseQuizSessionReturn
} from './useQuizSession';
```

If any are missing, add them.

Also create a quick integration verification by checking the types flow correctly:
1. LearnerProfile from types.ts
2. classifyTopics from adaptiveQuizService uses LearnerProfile
3. useQuizSession accepts profile?: LearnerProfile | null
4. generateProfileAwareQuestions accepts QuestionRequest[]
  </action>
  <verify>
Run `npx tsc --noEmit` - should pass.
Verify UseQuizSessionOptions is exported from hooks/index.ts.
Check that profile parameter is optional in the exported type.
  </verify>
  <done>
All hooks types are properly exported.
Profile parameter is optional, enabling gradual rollout.
Type flow is verified from LearnerProfile through to question generation.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit` passes
2. generateProfileAwareQuestions exists in geminiService.ts
3. QuizQuestion interface includes optional topic field
4. useQuizSession accepts optional profile parameter
5. When profile provided: uses adaptive generation with difficulty mixing
6. When profile missing: falls back to static generation
7. Generated questions include topic field for frustration tracking
8. Mastery percentage passed to Gemini in prompt for each question
</verification>

<success_criteria>
- [ ] generateProfileAwareQuestions function generates questions with mastery context
- [ ] Gemini prompt includes mastery percentage (0-100) and target difficulty for each question
- [ ] QuizQuestion interface includes optional topic field (at line ~112, in QUIZ & SESSION TYPES)
- [ ] useQuizSession accepts optional LearnerProfile parameter
- [ ] Adaptive generation uses classifyTopics -> mixDifficulty -> orderTopics -> generateProfileAwareQuestions
- [ ] Child with 80% mastery gets review (easy) questions, child with 40% gets scaffolding (easy) questions
- [ ] Learning zone (50-80% mastery) topics get medium difficulty questions
- [ ] Graceful fallback to static generation when profile unavailable
- [ ] Profile is updated after quiz completion via processQuizSignal (ADAPT-02)
- [ ] All new code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-profile-aware-quiz-generation/02-03-SUMMARY.md`
</output>
