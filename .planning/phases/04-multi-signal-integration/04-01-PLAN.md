---
phase: 04-multi-signal-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/signalWeights.ts
  - types.ts
  - lib/index.ts
autonomous: true

must_haves:
  truths:
    - "Signal types distinguish quiz, evaluation, engagement, and parent note sources"
    - "Confidence weights are configurable per signal type (95% eval, 70% quiz, 60% engagement, 40% note)"
    - "Recency decay reduces confidence for stale evidence"
    - "TopicMastery tracks multi-dimensional metrics (accuracy, speed, consistency)"
  artifacts:
    - path: "lib/signalWeights.ts"
      provides: "Evidence hierarchy configuration and confidence calculation"
      exports: ["getBaseConfidence", "applyRecencyDecay", "applySampleSizeBoost", "calculateSignalConfidence", "SIGNAL_WEIGHTS"]
    - path: "types.ts"
      provides: "Signal, EngagementMetrics, ParentNote types"
      contains: "SignalType"
  key_links:
    - from: "lib/signalWeights.ts"
      to: "types.ts"
      via: "Signal type import"
      pattern: "import.*Signal.*from"
---

<objective>
Create signal types and confidence weighting foundation for multi-evidence profile fusion.

Purpose: Enables the learner profile to integrate multiple evidence sources (school evaluations, quizzes, engagement patterns, parent observations) with appropriate weighting based on reliability.

Output:
- `lib/signalWeights.ts` with confidence calculation functions
- Extended `types.ts` with Signal, EngagementMetrics, ParentNote types
- Multi-dimensional TopicMastery extensions
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-multi-signal-integration/04-RESEARCH.md

# Existing types to extend
@types.ts
@lib/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Signal Types and Extend TopicMastery</name>
  <files>types.ts</files>
  <action>
Add the following types after the RECOMMENDATION ENGINE TYPES section:

```typescript
// ==========================================
// MULTI-SIGNAL INTEGRATION TYPES (Phase 4)
// ==========================================

/**
 * Signal source type for profile updates
 * Each type has different confidence weighting
 */
export type SignalType = 'quiz' | 'evaluation' | 'engagement' | 'parent_note';

/**
 * A learning signal from any source
 * Used for confidence-weighted Bayesian fusion
 */
export interface Signal {
  type: SignalType;
  pKnown: number;           // Estimated mastery from this signal (0-1)
  confidence: number;       // Base confidence (0-1), before recency/sample adjustments
  recency: number;          // Days ago (0 = today)
  sampleSize: number;       // Questions/data points behind estimate
}

/**
 * Engagement metrics captured during quiz session
 * Used to detect avoidance and low-effort patterns
 */
export interface EngagementMetrics {
  sessionDuration: number;        // Milliseconds spent in session
  questionsAnswered: number;      // Total answered
  questionsAvailable: number;     // Total loaded
  completionRate: number;         // 0-1, answered/available
  averageTimePerQuestion: number; // Milliseconds
  earlyExitDetected: boolean;     // Left before finishing
  rushingDetected: boolean;       // Answered too fast across all questions
}

/**
 * Engagement analysis result
 */
export interface EngagementSignal {
  level: 'high' | 'medium' | 'low' | 'avoidance';
  confidence: number;              // 0-1
  reasoning: string[];             // Hebrew explanation strings
  impactOnMastery: number;        // -0.1 to 0.1 adjustment to pKnown
}

/**
 * Category for parent observation notes
 */
export type ParentNoteCategory = 'guessed' | 'struggled' | 'skipped_step' | 'misunderstood' | 'other';

/**
 * Parent observation note during quiz review
 * Provides qualitative context for profile adjustments
 */
export interface ParentNote {
  id: string;
  childId: string;
  familyId: string;
  parentId: string;
  sessionId: string;        // Which quiz session
  questionIndex: number;    // Which question (0-based)
  topic: string;
  note: string;             // Free-form parent observation
  category: ParentNoteCategory;
  timestamp: number;
}

/**
 * Result of fusing multiple signals
 */
export interface FusedSignal {
  pKnown: number;
  confidence: number;
  dominantSignal: SignalType;
}
```

Also EXTEND the TopicMastery interface (add after `lastAttempt: number;`):

```typescript
  // Multi-dimensional tracking (Phase 4+)
  dimensions?: {
    accuracy: number;           // 0-1, raw correct rate
    speed: number;              // 0-1, relative to expected (1.0 = on pace)
    consistency: number;        // 0-1, 1 - variance across attempts
  };

  questionTypeBreakdown?: {
    multiple_choice?: number;    // pKnown for MC questions
    word_problems?: number;      // pKnown for word problems
    calculations?: number;       // pKnown for pure calculations
  };

  lastSignalType?: SignalType;
  lastEngagementLevel?: EngagementSignal['level'];

  parentNotes?: Array<{
    noteId: string;
    category: ParentNoteCategory;
    timestamp: number;
  }>;
```

IMPORTANT: Add imports for new types at top of the types section comments where needed.
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors</verify>
  <done>SignalType, Signal, EngagementMetrics, EngagementSignal, ParentNote, ParentNoteCategory, FusedSignal types exist. TopicMastery has dimensions, questionTypeBreakdown, lastSignalType, lastEngagementLevel, parentNotes fields.</done>
</task>

<task type="auto">
  <name>Task 2: Create Signal Weights Module</name>
  <files>lib/signalWeights.ts</files>
  <action>
Create new file `lib/signalWeights.ts`:

```typescript
/**
 * Signal Weights - Evidence Hierarchy Configuration
 *
 * Implements confidence-weighted Bayesian fusion for multi-signal
 * profile updates. Based on ITS research (VanLehn et al., 2005).
 *
 * Evidence hierarchy:
 * - Evaluation: 95% confidence (teacher-validated, comprehensive)
 * - Quiz: 70% confidence (consistent but limited scope)
 * - Engagement: 60% confidence (indirect but revealing)
 * - Parent note: 40% confidence (subjective but valuable context)
 */

import { Signal, SignalType, FusedSignal } from '../types';

/**
 * Base confidence weights by signal type
 * Reflects inherent reliability of each evidence source
 */
export const SIGNAL_WEIGHTS: Record<SignalType, number> = {
  evaluation: 0.95,    // Teacher-validated, comprehensive
  quiz: 0.70,          // Consistent but limited scope
  engagement: 0.60,    // Indirect measure but revealing
  parent_note: 0.40    // Subjective but valuable context
};

/**
 * Recency decay configuration
 * Evidence decays over time: 100% today -> 50% at HALF_LIFE_DAYS
 */
export const RECENCY_CONFIG = {
  HALF_LIFE_DAYS: 30,  // 50% confidence at 30 days
  MIN_CONFIDENCE: 0.05 // Never fully discount evidence
};

/**
 * Sample size configuration for confidence boost
 */
export const SAMPLE_SIZE_CONFIG = {
  SATURATION_POINT: 10 // 10 samples for ~63% of max confidence
};

/**
 * Get base confidence for a signal type
 */
export function getBaseConfidence(signalType: SignalType): number {
  return SIGNAL_WEIGHTS[signalType] ?? 0.5;
}

/**
 * Apply recency decay to confidence
 * Uses exponential decay: confidence * e^(-0.5 * days / halfLife)
 *
 * @param baseConfidence - Starting confidence (0-1)
 * @param daysAgo - Days since signal was captured
 * @returns Adjusted confidence with decay applied
 */
export function applyRecencyDecay(
  baseConfidence: number,
  daysAgo: number
): number {
  const decayRate = 0.5; // Corresponds to 50% at HALF_LIFE_DAYS
  const decayFactor = Math.exp(-decayRate * daysAgo / RECENCY_CONFIG.HALF_LIFE_DAYS);
  return Math.max(RECENCY_CONFIG.MIN_CONFIDENCE, baseConfidence * decayFactor);
}

/**
 * Adjust confidence based on sample size
 * More data = higher confidence
 *
 * Formula: baseConfidence * (1 - e^(-sampleSize / saturationPoint))
 * - 1 sample: ~9% of base
 * - 5 samples: ~40% of base
 * - 10 samples: ~63% of base
 * - 20 samples: ~86% of base
 *
 * @param baseConfidence - Starting confidence (0-1)
 * @param sampleSize - Number of data points
 * @returns Adjusted confidence based on sample size
 */
export function applySampleSizeBoost(
  baseConfidence: number,
  sampleSize: number
): number {
  if (sampleSize <= 0) return RECENCY_CONFIG.MIN_CONFIDENCE;

  const boost = 1 - Math.exp(-sampleSize / SAMPLE_SIZE_CONFIG.SATURATION_POINT);
  return baseConfidence * boost;
}

/**
 * Calculate final confidence for a signal
 * Combines base confidence, recency decay, and sample size boost
 *
 * @param signal - The signal to calculate confidence for
 * @returns Final confidence value (clamped to [0.05, 0.95])
 */
export function calculateSignalConfidence(signal: Signal): number {
  const base = getBaseConfidence(signal.type);
  const withRecency = applyRecencyDecay(base, signal.recency);
  const final = applySampleSizeBoost(withRecency, signal.sampleSize);

  // Clamp to valid range
  return Math.max(0.05, Math.min(0.95, final));
}

/**
 * Fuse multiple signals into single mastery estimate
 * Uses confidence-weighted average (Bayesian fusion)
 *
 * P(mastery | all signals) = Sum(confidence_i * p_i) / Sum(confidence_i)
 *
 * @param signals - Array of signals to fuse
 * @returns Fused mastery estimate with composite confidence
 */
export function fuseSignals(signals: Signal[]): FusedSignal {
  if (signals.length === 0) {
    return {
      pKnown: 0.5, // Neutral prior
      confidence: 0.0,
      dominantSignal: 'quiz'
    };
  }

  // Calculate adjusted confidence for each signal
  const weighted = signals.map(signal => ({
    signal,
    adjustedConfidence: calculateSignalConfidence(signal)
  }));

  // Confidence-weighted average
  const totalWeight = weighted.reduce((sum, w) => sum + w.adjustedConfidence, 0);

  if (totalWeight === 0) {
    return {
      pKnown: 0.5,
      confidence: 0.0,
      dominantSignal: signals[0]?.type ?? 'quiz'
    };
  }

  const weightedSum = weighted.reduce(
    (sum, w) => sum + w.adjustedConfidence * w.signal.pKnown,
    0
  );

  const fusedPKnown = weightedSum / totalWeight;

  // Composite confidence (average of contributing confidences)
  const avgConfidence = totalWeight / weighted.length;

  // Find dominant signal (highest adjusted confidence)
  const dominant = weighted.reduce((max, w) =>
    w.adjustedConfidence > max.adjustedConfidence ? w : max
  );

  return {
    pKnown: Math.max(0, Math.min(1, fusedPKnown)),
    confidence: avgConfidence,
    dominantSignal: dominant.signal.type
  };
}

/**
 * Calculate days since a timestamp
 */
export function daysSince(timestamp: number): number {
  const now = Date.now();
  const diff = now - timestamp;
  return Math.floor(diff / (1000 * 60 * 60 * 24));
}
```
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors</verify>
  <done>lib/signalWeights.ts exports getBaseConfidence, applyRecencyDecay, applySampleSizeBoost, calculateSignalConfidence, fuseSignals, daysSince, SIGNAL_WEIGHTS, RECENCY_CONFIG, SAMPLE_SIZE_CONFIG</done>
</task>

<task type="auto">
  <name>Task 3: Export from lib/index.ts</name>
  <files>lib/index.ts</files>
  <action>
Add exports for the new signal weights module after the Learner Model exports:

```typescript
// Signal Weights (Phase 4)
export {
  getBaseConfidence,
  applyRecencyDecay,
  applySampleSizeBoost,
  calculateSignalConfidence,
  fuseSignals,
  daysSince,
  SIGNAL_WEIGHTS,
  RECENCY_CONFIG,
  SAMPLE_SIZE_CONFIG
} from './signalWeights';
```
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors</verify>
  <done>Signal weights functions and constants exported from lib/index.ts</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Types correctly extend existing types.ts without breaking existing code
3. Signal weights module exports all required functions
</verification>

<success_criteria>
- SignalType, Signal, EngagementMetrics, ParentNote types exist in types.ts
- TopicMastery extended with multi-dimensional fields
- lib/signalWeights.ts provides confidence calculation functions
- All functions exported from lib/index.ts
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-multi-signal-integration/04-01-SUMMARY.md`
</output>
