---
phase: 04-multi-signal-integration
plan: 03
type: execute
wave: 2
depends_on:
  - "04-01"
  - "04-02"
files_modified:
  - services/signalService.ts
autonomous: true

must_haves:
  truths:
    - "School evaluation upload triggers profile update with 95% confidence weight"
    - "Evaluation signals dominate over quiz signals in fusion"
    - "Engagement signals adjust mastery based on session behavior"
    - "Parent note signals reduce confidence when guessing detected"
    - "Fire-and-forget pattern maintained - errors never block UI"
  artifacts:
    - path: "services/signalService.ts"
      provides: "Signal processors for all four signal types"
      exports: ["processQuizSignal", "processEvaluationSignal", "processEngagementSignal", "processParentNoteSignal"]
  key_links:
    - from: "services/signalService.ts"
      to: "lib/signalWeights.ts"
      via: "fuseSignals import for Bayesian fusion"
      pattern: "import.*fuseSignals.*from"
    - from: "services/signalService.ts"
      to: "lib/engagementDetector.ts"
      via: "analyzeEngagement import"
      pattern: "import.*analyzeEngagement.*from"
---

<objective>
Extend signal service with processors for evaluations, engagement, and parent notes.

Purpose: Integrates all four evidence sources (quiz, evaluation, engagement, parent note) into the learner profile using confidence-weighted Bayesian fusion. Evaluation signals carry highest weight, ensuring teacher assessments dominate profile calculations.

Output: Extended `services/signalService.ts` with processEvaluationSignal, processEngagementSignal, processParentNoteSignal
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-multi-signal-integration/04-RESEARCH.md

# Existing signal service to extend
@services/signalService.ts

# Signal weights and engagement detector
@lib/signalWeights.ts
@lib/engagementDetector.ts

# Types
@types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add imports and helper functions to signalService.ts</name>
  <files>services/signalService.ts</files>
  <action>
Update imports at the top of `services/signalService.ts`:

```typescript
import {
  StudySession,
  TopicMastery,
  LearnerProfile,
  ChildProfile,
  GradeLevel,
  Evaluation,
  EngagementMetrics,
  ParentNote,
  Signal,
  SignalType
} from '../types';
import {
  updateBKT,
  getBKTParams,
  calculateTrend,
  logger,
  ProfileUpdateError,
  retry,
  fuseSignals,
  daysSince,
  getBaseConfidence,
  analyzeEngagement
} from '../lib';
import { getProfile, updateProfile, initializeProfile } from './profileService';
```

Add helper function after extractTopicPerformance:

```typescript
/**
 * Create a Signal from existing TopicMastery data
 * Used as the "prior" when fusing with new signals
 */
function createSignalFromMastery(
  mastery: TopicMastery,
  defaultType: SignalType = 'quiz'
): Signal {
  return {
    type: mastery.lastSignalType || defaultType,
    pKnown: mastery.pKnown,
    confidence: getBaseConfidence(mastery.lastSignalType || defaultType),
    recency: daysSince(mastery.lastAttempt),
    sampleSize: mastery.attempts
  };
}

/**
 * Update topic mastery by fusing existing data with new signal
 * Uses confidence-weighted Bayesian fusion
 */
function fuseTopicWithSignal(
  existing: TopicMastery | undefined,
  topic: string,
  subjectId: string,
  newSignal: Signal,
  grade: GradeLevel
): TopicMastery {
  const params = getBKTParams(grade);

  // Initialize if first time seeing this topic
  if (!existing) {
    return {
      topic,
      subjectId,
      pKnown: newSignal.pKnown,
      attempts: newSignal.sampleSize,
      correctCount: Math.round(newSignal.pKnown * newSignal.sampleSize),
      incorrectCount: Math.round((1 - newSignal.pKnown) * newSignal.sampleSize),
      averageTime: 0,
      recentTrend: 'stable',
      performanceWindow: [],
      firstAttempt: Date.now(),
      lastAttempt: Date.now(),
      lastSignalType: newSignal.type
    };
  }

  // Create signal from existing mastery
  const existingSignal = createSignalFromMastery(existing);

  // Fuse signals
  const fused = fuseSignals([existingSignal, newSignal]);

  return {
    ...existing,
    pKnown: fused.pKnown,
    lastAttempt: Date.now(),
    lastSignalType: fused.dominantSignal
  };
}
```
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors</verify>
  <done>Imports updated, createSignalFromMastery and fuseTopicWithSignal helper functions added</done>
</task>

<task type="auto">
  <name>Task 2: Add processEvaluationSignal function</name>
  <files>services/signalService.ts</files>
  <action>
Add after bootstrapProfile function:

```typescript
/**
 * Process school evaluation signal and update profile
 *
 * Evaluation signals carry highest weight (95% confidence).
 * Teacher assessments dominate over quiz-based estimates.
 *
 * Fire-and-forget: Errors logged but never thrown (profile updates are non-blocking).
 *
 * @param evaluation - School evaluation with extracted topics
 * @param child - Child profile (needed for grade level)
 */
export async function processEvaluationSignal(
  evaluation: Evaluation,
  child: ChildProfile
): Promise<void> {
  try {
    logger.info('signalService: Processing evaluation signal', {
      evaluationId: evaluation.id,
      childId: evaluation.childId,
      testName: evaluation.testName,
      weakTopics: evaluation.weakTopics.length,
      strongTopics: evaluation.strongTopics.length
    });

    // 1. Fetch or initialize profile
    let profile = await getProfile(evaluation.childId);

    if (!profile) {
      profile = initializeProfile(evaluation.childId, evaluation.familyId);
      logger.info('signalService: Initializing profile from evaluation', {
        childId: evaluation.childId
      });
    }

    const daysAgo = daysSince(evaluation.date);

    // 2. Process strong topics (teacher-marked as mastered)
    for (const topic of evaluation.strongTopics) {
      const evaluationSignal: Signal = {
        type: 'evaluation',
        pKnown: 0.90,        // Strong = 90% mastery
        confidence: 0.95,     // High confidence (teacher assessment)
        recency: daysAgo,
        sampleSize: evaluation.questions?.filter(q => q.topic === topic).length || 5
      };

      profile.topicMastery[topic] = fuseTopicWithSignal(
        profile.topicMastery[topic],
        topic,
        evaluation.subject,
        evaluationSignal,
        child.grade
      );
    }

    // 3. Process weak topics (teacher-marked as needing work)
    for (const topic of evaluation.weakTopics) {
      const evaluationSignal: Signal = {
        type: 'evaluation',
        pKnown: 0.30,        // Weak = 30% mastery
        confidence: 0.95,
        recency: daysAgo,
        sampleSize: evaluation.questions?.filter(q => q.topic === topic).length || 5
      };

      profile.topicMastery[topic] = fuseTopicWithSignal(
        profile.topicMastery[topic],
        topic,
        evaluation.subject,
        evaluationSignal,
        child.grade
      );
    }

    // 4. Process individual questions if available (more granular)
    if (evaluation.questions && evaluation.questions.length > 0) {
      const topicQuestions: Record<string, { correct: number; total: number }> = {};

      for (const q of evaluation.questions) {
        const topic = q.topic || 'general';
        if (!topicQuestions[topic]) {
          topicQuestions[topic] = { correct: 0, total: 0 };
        }
        topicQuestions[topic].total++;
        if (q.isCorrect) {
          topicQuestions[topic].correct++;
        }
      }

      // Create signals from per-topic performance
      for (const [topic, perf] of Object.entries(topicQuestions)) {
        // Skip if already processed via weak/strong topics
        if (evaluation.weakTopics.includes(topic) || evaluation.strongTopics.includes(topic)) {
          continue;
        }

        const accuracy = perf.correct / perf.total;
        const evaluationSignal: Signal = {
          type: 'evaluation',
          pKnown: accuracy,
          confidence: 0.95,
          recency: daysAgo,
          sampleSize: perf.total
        };

        profile.topicMastery[topic] = fuseTopicWithSignal(
          profile.topicMastery[topic],
          topic,
          evaluation.subject,
          evaluationSignal,
          child.grade
        );
      }
    }

    // 5. Persist with retry (fire-and-forget pattern)
    await retry(
      () => updateProfile(evaluation.childId, profile!),
      { maxRetries: 2, context: 'processEvaluationSignal' }
    );

    logger.info('signalService: Evaluation signal processed', {
      evaluationId: evaluation.id,
      topicsUpdated: evaluation.strongTopics.length + evaluation.weakTopics.length
    });

  } catch (error) {
    // Fire-and-forget: Log but don't rethrow
    logger.error('signalService: Evaluation signal processing failed', {
      evaluationId: evaluation.id,
      childId: evaluation.childId
    }, error);
  }
}
```
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors</verify>
  <done>processEvaluationSignal function added with 95% confidence weight for teacher assessments</done>
</task>

<task type="auto">
  <name>Task 3: Add processEngagementSignal and processParentNoteSignal functions</name>
  <files>services/signalService.ts</files>
  <action>
Add after processEvaluationSignal:

```typescript
/**
 * Process engagement signal from quiz session
 *
 * Engagement modifies confidence, not mastery directly.
 * Low engagement = lower confidence in existing estimate.
 *
 * Fire-and-forget: Errors logged but never thrown.
 *
 * @param childId - Child who completed the session
 * @param familyId - Family ID for isolation
 * @param topic - Topic the session covered
 * @param subjectId - Subject ID
 * @param metrics - Engagement metrics from session
 * @param grade - Child's grade level
 */
export async function processEngagementSignal(
  childId: string,
  familyId: string,
  topic: string,
  subjectId: string,
  metrics: EngagementMetrics,
  grade: GradeLevel
): Promise<void> {
  try {
    // Analyze engagement
    const engagement = analyzeEngagement(metrics);

    logger.info('signalService: Processing engagement signal', {
      childId,
      topic,
      level: engagement.level,
      impact: engagement.impactOnMastery
    });

    // Skip if no impact
    if (engagement.impactOnMastery === 0) {
      logger.debug('signalService: No engagement impact, skipping', { childId, topic });
      return;
    }

    // Fetch profile
    let profile = await getProfile(childId);
    if (!profile) {
      logger.warn('signalService: No profile for engagement signal, skipping', { childId });
      return;
    }

    // Get or check topic mastery
    const topicMastery = profile.topicMastery[topic];
    if (!topicMastery) {
      // No quiz data yet for this topic, skip engagement signal
      logger.warn('signalService: No quiz data for topic, skipping engagement', {
        childId,
        topic
      });
      return;
    }

    // Apply engagement impact to pKnown
    // Engagement modifies confidence, not mastery directly
    // Low engagement = lower confidence in existing estimate
    const adjustedPKnown = Math.max(0, Math.min(1,
      topicMastery.pKnown + engagement.impactOnMastery
    ));

    profile.topicMastery[topic] = {
      ...topicMastery,
      pKnown: adjustedPKnown,
      lastEngagementLevel: engagement.level
    };

    // Update profile
    await retry(
      () => updateProfile(childId, profile!),
      { maxRetries: 1, context: 'processEngagementSignal' }
    );

    logger.info('signalService: Engagement signal processed', {
      childId,
      topic,
      level: engagement.level,
      oldPKnown: topicMastery.pKnown,
      newPKnown: adjustedPKnown
    });

  } catch (error) {
    // Fire-and-forget: Log but don't rethrow
    logger.error('signalService: Engagement signal failed', {
      childId,
      topic
    }, error);
  }
}

/**
 * Process parent note signal
 *
 * Parent notes provide qualitative context that modifies confidence.
 * "Guessed correctly" lowers mastery slightly.
 * "Struggled" indicates lower mastery than raw accuracy.
 *
 * Fire-and-forget: Errors logged but never thrown.
 *
 * @param note - Parent observation note
 * @param questionCorrect - Whether the question was answered correctly
 */
export async function processParentNoteSignal(
  note: ParentNote,
  questionCorrect: boolean
): Promise<void> {
  try {
    logger.info('signalService: Processing parent note', {
      childId: note.childId,
      topic: note.topic,
      category: note.category
    });

    // Fetch profile
    let profile = await getProfile(note.childId);
    if (!profile) {
      logger.warn('signalService: No profile for parent note, skipping', {
        childId: note.childId
      });
      return;
    }

    // Get topic mastery
    const topicMastery = profile.topicMastery[note.topic];
    if (!topicMastery) {
      logger.warn('signalService: No topic mastery for note, skipping', {
        childId: note.childId,
        topic: note.topic
      });
      return;
    }

    // Calculate adjustment based on note category + correctness
    let adjustment = 0;

    switch (note.category) {
      case 'guessed':
        // If guessed and correct, lower confidence in mastery
        // If guessed and wrong, no adjustment (expected)
        if (questionCorrect) {
          adjustment = -0.02; // Small decrease
          logger.debug('signalService: Guessed correct - lowering mastery', {
            topic: note.topic,
            adjustment
          });
        }
        break;

      case 'struggled':
        // Struggled indicates lower mastery than raw accuracy suggests
        adjustment = -0.03;
        break;

      case 'skipped_step':
        // Skipped step: knows algorithm but execution shaky
        adjustment = -0.02;
        break;

      case 'misunderstood':
        // Misunderstood: fundamental gap
        adjustment = -0.05;
        break;

      case 'other':
        // No automatic adjustment for 'other' - just record the note
        adjustment = 0;
        break;
    }

    // Apply adjustment
    const adjustedPKnown = Math.max(0, Math.min(1,
      topicMastery.pKnown + adjustment
    ));

    // Store note reference for transparency
    const parentNotes = topicMastery.parentNotes || [];
    parentNotes.push({
      noteId: note.id,
      category: note.category,
      timestamp: note.timestamp
    });

    profile.topicMastery[note.topic] = {
      ...topicMastery,
      pKnown: adjustedPKnown,
      parentNotes
    };

    // Update profile
    await retry(
      () => updateProfile(note.childId, profile!),
      { maxRetries: 1, context: 'processParentNoteSignal' }
    );

    logger.info('signalService: Parent note signal processed', {
      childId: note.childId,
      topic: note.topic,
      category: note.category,
      adjustment,
      oldPKnown: topicMastery.pKnown,
      newPKnown: adjustedPKnown
    });

  } catch (error) {
    // Fire-and-forget: Log but don't rethrow
    logger.error('signalService: Parent note signal failed', {
      noteId: note.id
    }, error);
  }
}
```
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors</verify>
  <done>processEngagementSignal and processParentNoteSignal functions added with fire-and-forget pattern</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. processEvaluationSignal uses 95% confidence for teacher assessments
3. processEngagementSignal applies mastery adjustments based on engagement level
4. processParentNoteSignal adjusts mastery based on note category
5. All signal processors follow fire-and-forget pattern (errors logged, not thrown)
</verification>

<success_criteria>
- processEvaluationSignal processes weak/strong topics with 95% confidence
- Evaluation signals dominate over quiz signals via confidence-weighted fusion
- processEngagementSignal applies -0.05 (low) or -0.10 (avoidance) adjustments
- processParentNoteSignal applies -0.02 to -0.05 adjustments based on category
- All processors use retry() for persistence
- Fire-and-forget pattern: errors never propagate to callers
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-multi-signal-integration/04-03-SUMMARY.md`
</output>
