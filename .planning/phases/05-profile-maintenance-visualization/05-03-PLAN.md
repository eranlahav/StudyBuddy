---
phase: 05-profile-maintenance-visualization
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - services/probeScheduler.ts
  - services/adaptiveQuizService.ts
  - services/index.ts
  - hooks/useQuizSession.ts
autonomous: true

must_haves:
  truths:
    - "Probe questions scheduled every 4-6 weeks for mastered topics"
    - "Probe interval doubles on success (4w -> 8w -> 16w), max 24 weeks"
    - "Failed probe demotes topic from mastered (pKnown 0.75)"
    - "Review mode triggers after 3+ week gap with 30% review questions"
    - "Probe topics included in quiz question requests"
    - "Review mode detected in useQuizSession and adjusts question mix"
  artifacts:
    - path: "services/probeScheduler.ts"
      provides: "SM-2 based probe scheduling"
      exports: ["needsProbeQuestion", "scheduleNextProbe", "processProbeResult", "PROBE_CONFIG"]
    - path: "services/adaptiveQuizService.ts"
      provides: "Review mode detection and probe mixing"
      exports: ["shouldEnterReviewMode", "selectReviewTopics", "selectProbeTopics"]
    - path: "hooks/useQuizSession.ts"
      provides: "Wired probe and review mode integration"
      contains: "selectProbeTopics"
  key_links:
    - from: "services/probeScheduler.ts"
      to: "types.ts"
      via: "TopicMastery import (with nextProbeDate)"
      pattern: "import.*TopicMastery.*from.*types"
    - from: "services/adaptiveQuizService.ts"
      to: "services/probeScheduler.ts"
      via: "needsProbeQuestion import"
      pattern: "import.*needsProbeQuestion.*from.*probeScheduler"
    - from: "hooks/useQuizSession.ts"
      to: "services/adaptiveQuizService.ts"
      via: "selectProbeTopics and shouldEnterReviewMode imports"
      pattern: "import.*selectProbeTopics.*from.*adaptiveQuizService"
---

<objective>
Create the probe scheduler service, extend adaptive quiz service with review mode, and wire both into useQuizSession.

Purpose: Implement spaced repetition (SM-2) for mastery verification and "Welcome back" review mode for children returning after gaps. This keeps profiles accurate and eases children back into learning.

Output: `services/probeScheduler.ts` with SM-2 scheduling, extended `adaptiveQuizService.ts` with review mode and probe topic selection, wired `useQuizSession` that uses both.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-profile-maintenance-visualization/05-RESEARCH.md

# Dependencies from Plan 01
@types.ts  # Has nextProbeDate, probeIntervalDays on TopicMastery

# Existing service to extend
@services/adaptiveQuizService.ts
@lib/signalWeights.ts

# Hook to wire into
@hooks/useQuizSession.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create probe scheduler service</name>
  <files>services/probeScheduler.ts, services/index.ts</files>
  <action>
Create `services/probeScheduler.ts` with:

1. **PROBE_CONFIG** constant:
```typescript
export const PROBE_CONFIG = {
  /** Initial probe interval (4 weeks = 28 days) */
  INITIAL_INTERVAL_DAYS: 28,
  /** Maximum probe interval (24 weeks = 168 days) */
  MAX_INTERVAL_DAYS: 168,
  /** Probe question count per topic per quiz */
  QUESTIONS_PER_PROBE: 3,
  /** Minimum accuracy to pass probe (67% = 2/3 questions) */
  PASSING_ACCURACY: 0.67,
  /** pKnown to set after failed probe */
  FAILED_PROBE_PKNOWN: 0.75,
  /** Minimum pKnown to be eligible for probing */
  MIN_PROBE_PKNOWN: 0.8
};
```

2. **needsProbeQuestion(mastery: TopicMastery): boolean**
   - Return false if pKnown < 0.8 (only probe mastered topics)
   - Return false if nextProbeDate doesn't exist (new mastery)
   - Return true if Date.now() >= nextProbeDate

3. **scheduleNextProbe(mastery, probeResult?): TopicMastery**
   - If no nextProbeDate: set initial interval (28 days)
   - If probeResult provided:
     - Passed (>=67%): double interval (up to MAX_INTERVAL_DAYS)
     - Failed (<67%): reset to initial interval
   - Calculate nextProbeDate = Date.now() + (intervalDays * 24 * 60 * 60 * 1000)
   - Return updated TopicMastery with nextProbeDate and probeIntervalDays

4. **processProbeResult(mastery, correct, total): TopicMastery**
   - Calculate accuracy = correct / total
   - If failed (<67%):
     - Set pKnown to 0.75 (demote from mastered)
     - Log: "probeScheduler: Failed probe, demoting topic"
   - If passed:
     - Update lastAttempt to Date.now() (refresh)
   - Call scheduleNextProbe with result
   - Return updated mastery

Use `logger` from `../lib` for debug logging.
Import types from `../types`.

Export from services/index.ts.
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors

Manual verification:
- needsProbeQuestion returns false for pKnown 0.65
- needsProbeQuestion returns true for mastered topic past nextProbeDate
- scheduleNextProbe doubles interval on success
- processProbeResult demotes on failure
  </verify>
  <done>
Probe scheduler implements SM-2 algorithm.
Initial 4-week probe interval, doubles on success up to 24 weeks.
Failed probes demote to pKnown 0.75 (success criteria #2).
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend adaptive quiz service with review mode</name>
  <files>services/adaptiveQuizService.ts</files>
  <action>
Add to `services/adaptiveQuizService.ts`:

1. **REVIEW_MODE_CONFIG** constant (add near top after existing constants):
```typescript
export const REVIEW_MODE_CONFIG = {
  /** Trigger review mode after this many days gap */
  GAP_THRESHOLD_DAYS: 21,  // 3 weeks
  /** Percentage of questions that should be review */
  REVIEW_PERCENTAGE: 0.30,  // 30%
  /** Minimum pKnown to be eligible for review */
  MIN_REVIEW_PKNOWN: 0.65
};
```

2. **shouldEnterReviewMode(lastSessionTimestamp: number): boolean**
   - Import daysSince from '../lib/signalWeights'
   - Return daysSince(lastSessionTimestamp) >= GAP_THRESHOLD_DAYS (21 days)

3. **selectReviewTopics(profile, currentSubjectId): string[]**
   - Filter topics: same subject, pKnown >= 0.65, lastAttempt >= 21 days ago
   - Sort by lastAttempt ascending (oldest first)
   - Return top 3 topic names

4. **selectProbeTopics(profile, subjectId): string[]**
   - Import needsProbeQuestion from './probeScheduler'
   - Filter topics: same subject, needsProbeQuestion returns true
   - Return topic names (max 2 per quiz)

5. **Export the new functions** (they're already in the same file)

Import `daysSince` from `../lib/signalWeights`.
Import `needsProbeQuestion` from `./probeScheduler`.
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors

Manual verification:
- shouldEnterReviewMode(21 days ago) returns true
- shouldEnterReviewMode(14 days ago) returns false
- selectReviewTopics filters by subject and pKnown threshold
- selectProbeTopics uses probeScheduler for eligibility
  </verify>
  <done>
Review mode triggers after 3+ week gap (success criteria #3).
30% review questions from previously-mastered topics.
Probe topics selected for mastery verification.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire probe and review mode into useQuizSession</name>
  <files>hooks/useQuizSession.ts</files>
  <action>
Integrate probe topic selection and review mode detection into the quiz session hook:

1. **Add imports at top:**
```typescript
import {
  classifyTopics,
  mixDifficulty,
  orderTopics,
  hasProfileData,
  shouldEnterReviewMode,
  selectReviewTopics,
  selectProbeTopics,
  REVIEW_MODE_CONFIG
} from '../services/adaptiveQuizService';
```

2. **Add review mode state:**
```typescript
// Add to state declarations (near fatigue/frustration state):
const [isReviewMode, setIsReviewMode] = useState(false);
```

3. **In loadQuestions, inside the adaptive generation block (after `const useAdaptive = ...`):**

Before building `orderedTopics`, check for review mode and probe topics:

```typescript
if (useAdaptive && profile) {
  // Check for review mode (3+ week gap)
  const lastSession = sessions?.length > 0
    ? Math.max(...sessions.filter(s => s.childId === child.id).map(s => s.date))
    : null;

  const inReviewMode = lastSession !== null && shouldEnterReviewMode(lastSession);
  setIsReviewMode(inReviewMode);

  if (inReviewMode) {
    logger.info('useQuizSession: Entering review mode', {
      daysSinceLastSession: Math.floor((Date.now() - lastSession!) / (1000 * 60 * 60 * 24))
    });
  }

  // Get probe topics (mastered topics due for verification)
  const probeTopics = selectProbeTopics(profile, subject.id);
  if (probeTopics.length > 0) {
    logger.info('useQuizSession: Including probe topics', { probeTopics });
  }

  // Get review topics (if in review mode)
  const reviewTopics = inReviewMode ? selectReviewTopics(profile, subject.id) : [];

  // Get available topics (from subject or just the session topic)
  const availableTopics = subject.topics?.length > 0 ? subject.topics : targetTopics;

  // Classify topics by mastery level
  const classification = classifyTopics(profile, availableTopics);

  // Merge probe and review topics into the classification
  // Probe topics go into mastered (for verification)
  // Review topics go into review bucket
  const augmentedClassification = {
    ...classification,
    // Add probe topics that aren't already in mastered
    mastered: [...new Set([...classification.mastered, ...probeTopics])],
    // Track review topics separately for the mix
    _reviewTopics: reviewTopics,
    _probeTopics: probeTopics
  };

  // Apply difficulty mixing with review mode adjustment
  // In review mode: 30% review topics, 50% target, 20% weak
  // Normal mode: 20% review, 50% target, 30% weak
  const mix = mixDifficulty(augmentedClassification, count, true);

  // If in review mode, ensure review topics are included
  if (inReviewMode && reviewTopics.length > 0) {
    const reviewCount = Math.ceil(count * REVIEW_MODE_CONFIG.REVIEW_PERCENTAGE);
    // Replace some target topics with review topics
    const reviewToAdd = reviewTopics.slice(0, reviewCount);
    mix.reviewTopics = [...new Set([...mix.reviewTopics, ...reviewToAdd])];
    logger.info('useQuizSession: Review mode question mix', {
      reviewCount,
      reviewTopics: mix.reviewTopics
    });
  }

  // Ensure probe topics are included in the final mix
  if (probeTopics.length > 0) {
    mix.reviewTopics = [...new Set([...mix.reviewTopics, ...probeTopics])];
  }

  // Order topics (easy to hard)
  const orderedTopics = orderTopics(mix);

  // ... rest of existing code for building requests and generating questions
}
```

4. **Add isReviewMode to the hook return:**
```typescript
return {
  // ... existing return values
  isReviewMode,  // NEW: for UI to show "Welcome back" banner
  // ...
};
```

5. **Update UseQuizSessionReturn interface:**
```typescript
export interface UseQuizSessionReturn extends QuizSessionState, FinalReviewState {
  // ... existing properties
  /** Whether quiz is in review mode (child returning after gap) */
  isReviewMode: boolean;
  // ...
}
```

Note: This integrates with the existing adaptive quiz flow. The key wiring is:
- `shouldEnterReviewMode()` detects 3+ week gap
- `selectProbeTopics()` finds mastered topics due for verification
- `selectReviewTopics()` finds topics to review in review mode
- Both are merged into the question mix before generation
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors

Manual verification in browser:
- Start quiz after 21+ day gap: review mode detected (check console logs)
- Quiz includes probe topics when mastered topics are due
- isReviewMode state exposed for UI banner
  </verify>
  <done>
Probe topics wired into quiz generation via selectProbeTopics().
Review mode detected via shouldEnterReviewMode() and adjusts mix to 30% review.
isReviewMode exposed for UI to show "Welcome back" banner.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Probe scheduling math verified:
   - Initial interval: 28 days (4 weeks)
   - After 1 success: 56 days (8 weeks)
   - After 2 successes: 112 days (16 weeks)
   - After 3 successes: 168 days (24 weeks, capped)
3. Review mode triggers at 21+ day gap
4. Review topics limited to 30% of questions
5. Probe topics limited to 2 per quiz
6. useQuizSession calls selectProbeTopics() during question generation
7. useQuizSession calls shouldEnterReviewMode() and adjusts mix accordingly
</verification>

<success_criteria>
- Probe questions scheduled every 4-6 weeks (success criteria #2)
- Probe interval doubles on success, up to 24 weeks
- Failed probes demote topic (pKnown 0.75)
- Review mode after 3+ week gap with 30% review questions (success criteria #3)
- selectProbeTopics() called and probe topics included in quiz requests
- shouldEnterReviewMode() called and review mode adjusts question mix
</success_criteria>

<output>
After completion, create `.planning/phases/05-profile-maintenance-visualization/05-03-SUMMARY.md`
</output>
