---
phase: 01-profile-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - services/profileService.ts
  - services/signalService.ts
  - services/index.ts
autonomous: true

must_haves:
  truths:
    - "Profile can be read from and written to Firestore subcollection"
    - "Quiz completion triggers profile update via processQuizSignal"
    - "Profile updates use fire-and-forget pattern (non-blocking)"
  artifacts:
    - path: "services/profileService.ts"
      provides: "Profile CRUD operations with Firestore"
      exports: ["getProfile", "updateProfile", "subscribeToProfile", "initializeProfile"]
    - path: "services/signalService.ts"
      provides: "Signal processing for profile updates"
      exports: ["processQuizSignal", "bootstrapProfile"]
    - path: "services/index.ts"
      provides: "Service re-exports"
      contains: "from './profileService'"
  key_links:
    - from: "services/signalService.ts"
      to: "services/profileService.ts"
      via: "getProfile, updateProfile imports"
      pattern: "import.*getProfile.*from.*profileService"
    - from: "services/signalService.ts"
      to: "lib/learnerModel.ts"
      via: "updateBKT, getBKTParams imports"
      pattern: "import.*updateBKT.*from"
---

<objective>
Create the profile service for Firestore CRUD operations and signal service for processing quiz completions into profile updates.

Purpose: These services form the backend of the profile system - profileService handles data persistence in Firestore subcollections, while signalService translates quiz results into BKT mastery updates without blocking the UI.

Output: Two new services that enable automatic profile learning from quiz activity.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-profile-foundation/01-RESEARCH.md

# Prior plan output
@.planning/phases/01-profile-foundation/01-01-SUMMARY.md

# Key existing files
@services/sessionsService.ts
@services/index.ts
@lib/index.ts
@types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Profile Service</name>
  <files>services/profileService.ts</files>
  <action>
Create new file services/profileService.ts following the sessionsService.ts pattern:

```typescript
/**
 * Profile Service
 *
 * Handles all Firestore operations for learner profiles.
 * Profiles are stored as subcollections under children documents:
 * /children/{childId}/learnerProfile/main
 *
 * This isolation prevents profile data from bloating children queries
 * and allows independent real-time subscriptions.
 */

import {
  doc,
  getDoc,
  setDoc,
  onSnapshot,
  Unsubscribe
} from 'firebase/firestore';
import { db } from '../firebaseConfig';
import { LearnerProfile } from '../types';
import { logger, DatabaseError } from '../lib';

/**
 * Get learner profile for a child
 * Returns null if profile doesn't exist yet (lazy initialization)
 */
export async function getProfile(childId: string): Promise<LearnerProfile | null> {
  try {
    const profileRef = doc(db, 'children', childId, 'learnerProfile', 'main');
    const snapshot = await getDoc(profileRef);

    if (!snapshot.exists()) {
      logger.debug('profileService: No profile found', { childId });
      return null;
    }

    return snapshot.data() as LearnerProfile;
  } catch (error) {
    logger.error('profileService: Failed to get profile', { childId }, error);
    throw new DatabaseError('Failed to get profile', { cause: error as Error });
  }
}

/**
 * Update or create learner profile
 * Uses merge:true to support partial updates
 */
export async function updateProfile(
  childId: string,
  profile: LearnerProfile
): Promise<void> {
  try {
    const profileRef = doc(db, 'children', childId, 'learnerProfile', 'main');

    await setDoc(profileRef, {
      ...profile,
      lastUpdated: Date.now()
    }, { merge: true });

    logger.debug('profileService: Profile updated', {
      childId,
      topicsCount: Object.keys(profile.topicMastery).length,
      totalQuizzes: profile.totalQuizzes
    });
  } catch (error) {
    logger.error('profileService: Failed to update profile', { childId }, error);
    throw new DatabaseError('Failed to update profile', { cause: error as Error });
  }
}

/**
 * Subscribe to profile changes
 * Real-time updates for dashboard display
 */
export function subscribeToProfile(
  childId: string,
  onData: (profile: LearnerProfile | null) => void,
  onError?: (error: Error) => void
): Unsubscribe {
  const profileRef = doc(db, 'children', childId, 'learnerProfile', 'main');

  return onSnapshot(
    profileRef,
    (snapshot) => {
      if (!snapshot.exists()) {
        onData(null);
      } else {
        onData(snapshot.data() as LearnerProfile);
      }
    },
    (error) => {
      logger.error('profileService: Subscription error', { childId }, error);
      onError?.(new DatabaseError('Failed to subscribe to profile', { cause: error }));
    }
  );
}

/**
 * Initialize empty profile for a child
 * Called when first quiz is completed
 */
export function initializeProfile(childId: string, familyId: string): LearnerProfile {
  return {
    childId,
    familyId,
    topicMastery: {},
    totalQuizzes: 0,
    totalQuestions: 0,
    lastUpdated: Date.now(),
    version: 1
  };
}
```
  </action>
  <verify>Run `npx tsc --noEmit` - no TypeScript errors</verify>
  <done>services/profileService.ts exists with getProfile, updateProfile, subscribeToProfile, initializeProfile functions</done>
</task>

<task type="auto">
  <name>Task 2: Create Signal Service</name>
  <files>services/signalService.ts</files>
  <action>
Create new file services/signalService.ts for processing quiz signals:

```typescript
/**
 * Signal Service
 *
 * Processes learning signals (quiz completions, evaluations) and
 * updates learner profiles using BKT algorithm.
 *
 * Key design: Fire-and-forget pattern - profile updates never block UI.
 * Errors are logged but don't break the quiz flow.
 */

import { StudySession, TopicMastery, LearnerProfile, ChildProfile, GradeLevel } from '../types';
import { updateBKT, getBKTParams, calculateTrend, logger, ProfileUpdateError, retry } from '../lib';
import { getProfile, updateProfile, initializeProfile } from './profileService';

/**
 * Extract topic-level performance from a quiz session
 * Groups questions by topic and tracks correct/incorrect answers
 */
function extractTopicPerformance(session: StudySession): Record<string, {
  correct: boolean[];
  subjectId: string;
}> {
  const topicPerf: Record<string, { correct: boolean[]; subjectId: string }> = {};

  // All questions in a session are for the same topic
  const topic = session.topic;

  if (!topicPerf[topic]) {
    topicPerf[topic] = { correct: [], subjectId: session.subjectId };
  }

  session.questions.forEach((q, idx) => {
    const correct = session.userAnswers?.[idx] === q.correctAnswerIndex;
    topicPerf[topic].correct.push(correct);
  });

  return topicPerf;
}

/**
 * Update topic mastery with new performance data
 */
function updateTopicMastery(
  existing: TopicMastery | undefined,
  performance: { correct: boolean[]; subjectId: string },
  topic: string,
  grade: GradeLevel
): TopicMastery {
  const params = getBKTParams(grade);

  // Initialize if first time seeing this topic
  let mastery: TopicMastery = existing || {
    topic,
    subjectId: performance.subjectId,
    pKnown: params.pInit,
    attempts: 0,
    correctCount: 0,
    incorrectCount: 0,
    averageTime: 0,
    recentTrend: 'stable',
    performanceWindow: [],
    firstAttempt: Date.now(),
    lastAttempt: Date.now()
  };

  // Apply BKT updates for each answer
  performance.correct.forEach(correct => {
    mastery.pKnown = updateBKT(mastery.pKnown, correct, params);
    mastery.attempts += 1;

    if (correct) {
      mastery.correctCount += 1;
    } else {
      mastery.incorrectCount += 1;
    }

    // Update performance window (last 10 attempts)
    mastery.performanceWindow.push(correct ? 1 : 0);
    if (mastery.performanceWindow.length > 10) {
      mastery.performanceWindow.shift();
    }
  });

  // Update trend
  mastery.recentTrend = calculateTrend(mastery.performanceWindow);
  mastery.lastAttempt = Date.now();

  return mastery;
}

/**
 * Process quiz signal and update profile
 *
 * This is the main entry point called after quiz completion.
 * Uses fire-and-forget pattern - errors are logged but never thrown
 * to the caller (quiz flow continues regardless).
 *
 * @param session - Completed quiz session
 * @param child - Child profile (needed for grade level)
 */
export async function processQuizSignal(
  session: StudySession,
  child: ChildProfile
): Promise<void> {
  try {
    logger.info('signalService: Processing quiz signal', {
      childId: session.childId,
      sessionId: session.id,
      topic: session.topic,
      score: `${session.score}/${session.totalQuestions}`
    });

    // 1. Fetch or initialize profile
    let profile = await getProfile(session.childId);

    if (!profile) {
      profile = initializeProfile(session.childId, session.familyId);
      logger.info('signalService: Initializing first profile', { childId: session.childId });
    }

    // 2. Extract performance by topic
    const topicPerf = extractTopicPerformance(session);

    // 3. Update BKT for each topic
    for (const [topic, perf] of Object.entries(topicPerf)) {
      const existingMastery = profile.topicMastery[topic];
      profile.topicMastery[topic] = updateTopicMastery(
        existingMastery,
        perf,
        topic,
        child.grade
      );
    }

    // 4. Update global metadata
    profile.totalQuizzes += 1;
    profile.totalQuestions += session.totalQuestions;

    // 5. Persist with retry
    await retry(
      () => updateProfile(session.childId, profile!),
      { maxRetries: 2, context: 'processQuizSignal' }
    );

    logger.info('signalService: Signal processed successfully', {
      childId: session.childId,
      topicsUpdated: Object.keys(topicPerf).length,
      newTotalQuizzes: profile.totalQuizzes
    });

  } catch (error) {
    // Log but don't rethrow - fire-and-forget pattern
    logger.error('signalService: Signal processing failed', {
      childId: session.childId,
      sessionId: session.id
    }, error);

    // Throw only if called directly (for testing) - in production this is caught by caller
    throw new ProfileUpdateError('Failed to process quiz signal', {
      cause: error as Error
    });
  }
}

/**
 * Bootstrap profile from existing quiz sessions
 * Used for children who have quiz history but no profile yet
 *
 * @param childId - Child to bootstrap
 * @param familyId - Family ID for multi-tenant isolation
 * @param existingSessions - All quiz sessions for this child
 * @param grade - Child's grade level
 */
export async function bootstrapProfile(
  childId: string,
  familyId: string,
  existingSessions: StudySession[],
  grade: GradeLevel
): Promise<LearnerProfile> {
  logger.info('signalService: Bootstrapping profile from history', {
    childId,
    sessionCount: existingSessions.length
  });

  // Start with empty profile
  let profile = initializeProfile(childId, familyId);

  // Sort sessions chronologically (oldest first)
  const sortedSessions = [...existingSessions].sort((a, b) => a.date - b.date);

  // Replay each session through the BKT algorithm
  for (const session of sortedSessions) {
    const topicPerf = extractTopicPerformance(session);

    for (const [topic, perf] of Object.entries(topicPerf)) {
      const existingMastery = profile.topicMastery[topic];
      profile.topicMastery[topic] = updateTopicMastery(
        existingMastery,
        perf,
        topic,
        grade
      );
    }

    profile.totalQuizzes += 1;
    profile.totalQuestions += session.totalQuestions;
  }

  // Save bootstrapped profile
  await updateProfile(childId, profile);

  logger.info('signalService: Profile bootstrapped', {
    childId,
    topicsTracked: Object.keys(profile.topicMastery).length,
    totalQuizzes: profile.totalQuizzes
  });

  return profile;
}
```
  </action>
  <verify>Run `npx tsc --noEmit` - no TypeScript errors</verify>
  <done>services/signalService.ts exists with processQuizSignal and bootstrapProfile functions</done>
</task>

<task type="auto">
  <name>Task 3: Update Services Index</name>
  <files>services/index.ts</files>
  <action>
Add exports for the new services to services/index.ts.

Add after the Statistics exports at the end of the file:

```typescript
// Profile & Learning Signals
export {
  getProfile,
  updateProfile,
  subscribeToProfile,
  initializeProfile
} from './profileService';

export {
  processQuizSignal,
  bootstrapProfile
} from './signalService';
```
  </action>
  <verify>Can import { getProfile, processQuizSignal } from './services'</verify>
  <done>All new service functions are exported from services/index.ts</done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit` passes with no errors
2. Profile service functions importable: `import { getProfile, updateProfile } from './services'`
3. Signal service functions importable: `import { processQuizSignal, bootstrapProfile } from './services'`
4. Services follow existing patterns (logger usage, error handling, DatabaseError)
</verification>

<success_criteria>
- profileService.ts provides CRUD operations for Firestore subcollection /children/{childId}/learnerProfile/main
- signalService.ts processes quiz sessions into BKT updates
- processQuizSignal uses fire-and-forget pattern (logs errors, doesn't crash)
- bootstrapProfile can reconstruct profile from historical sessions
- All exports available from services/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/01-profile-foundation/01-02-SUMMARY.md`
</output>
