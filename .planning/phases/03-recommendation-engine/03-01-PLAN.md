---
phase: 03-recommendation-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - types.ts
  - services/recommendationService.ts
  - services/index.ts
autonomous: true

must_haves:
  truths:
    - "scoreTopic returns 0-100 composite score combining mastery (30%), urgency (40%), and goals (30%)"
    - "generateRecommendations returns 3-5 balanced topics across weakness/growth/maintenance categories"
    - "Each recommendation includes priority badge, confidence level, and reasoning array"
  artifacts:
    - path: "types.ts"
      provides: "LearningGoal, TopicScore, Recommendation, OverrideReason types"
      contains: "interface LearningGoal"
    - path: "services/recommendationService.ts"
      provides: "Topic scoring and recommendation generation"
      exports: ["scoreTopic", "generateRecommendations", "recordOverride"]
  key_links:
    - from: "services/recommendationService.ts"
      to: "types.ts"
      via: "import"
      pattern: "import.*LearningGoal.*from"
---

<objective>
Create core types and recommendation scoring service

Purpose: Establish the foundation for AI-powered topic recommendations with multi-factor scoring (mastery + urgency + goals) and balanced recommendation strategy (30% weakness, 40% growth, 30% maintenance).

Output: Types for recommendations/goals/overrides in types.ts, scoring algorithms in recommendationService.ts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-recommendation-engine/03-RESEARCH.md

# Existing types and services to extend
@types.ts
@services/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add recommendation types to types.ts</name>
  <files>types.ts</files>
  <action>
Add new types after the ADAPTIVE_QUIZ_CONSTANTS section:

```typescript
// ==========================================
// RECOMMENDATION ENGINE TYPES (Phase 3)
// ==========================================

/**
 * Parent-defined learning goal for a child
 * Influences recommendation scoring
 */
export interface LearningGoal {
  id: string;
  childId: string;
  familyId: string;
  subjectId: string;           // Subject this goal belongs to
  topic: string;               // From subject.topics dropdown
  targetDate: number | null;   // Optional deadline timestamp
  description: string;         // Parent's notes (not parsed)
  createdAt: number;
  createdBy: string;           // Parent UID
}

/**
 * Scored topic from recommendation algorithm
 */
export interface TopicScore {
  topic: string;
  score: number;               // 0-100 composite score
  masteryScore: number;        // 0-100 (lower mastery = higher score)
  urgencyScore: number;        // 0-100 (upcoming tests boost score)
  goalScore: number;           // 0-100 (matches parent goals)
  confidence: 'low' | 'medium' | 'high';
  reasoning: string[];         // Hebrew explanation strings
}

/**
 * Final recommendation with priority and category
 */
export interface Recommendation {
  topic: string;
  priority: 'urgent' | 'important' | 'review';
  score: number;
  confidence: 'low' | 'medium' | 'high';
  reasoning: string[];
  category: 'weakness' | 'growth' | 'maintenance';
}

/**
 * Reason for parent override
 */
export type OverrideReason =
  | 'too_easy'
  | 'too_hard'
  | 'wrong_priority'
  | 'other';

/**
 * Logged override for future calibration
 */
export interface RecommendationOverride {
  id: string;
  childId: string;
  familyId: string;
  parentId: string;
  topic: string;
  reason: OverrideReason;
  customReason?: string;       // If reason === 'other'
  timestamp: number;
}

/**
 * Weights for multi-factor scoring
 */
export interface ScoringWeights {
  mastery: number;             // Default: 0.30 (30%)
  urgency: number;             // Default: 0.40 (40%)
  goals: number;               // Default: 0.30 (30%)
}

/**
 * Default scoring weights (30/40/30 split)
 */
export const DEFAULT_SCORING_WEIGHTS: ScoringWeights = {
  mastery: 0.30,
  urgency: 0.40,
  goals: 0.30
};
```

Note: UpcomingTest.topics is a string[] array (not comma-separated string).
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>LearningGoal, TopicScore, Recommendation, OverrideReason, RecommendationOverride, ScoringWeights types exist with correct fields</done>
</task>

<task type="auto">
  <name>Task 2: Create recommendationService.ts with scoring algorithms</name>
  <files>services/recommendationService.ts</files>
  <action>
Create `services/recommendationService.ts` with:

1. **calculateMasteryScore(topicMastery)** - Inverse of pKnown:
   - null/undefined: return 50 (neutral for new topics)
   - pKnown < 0.3: return 95 (cap to avoid overwhelming)
   - pKnown >= 0.8: return 20 (mastered but still maintenance)
   - Otherwise: (1 - pKnown) * 100

2. **calculateUrgencyScore(topic, upcomingTests)** - Test proximity:
   - Filter tests where topic appears in test.topics array (use `.includes()`)
   - Find nearest test by date
   - Calculate daysUntil = Math.ceil((test.date - Date.now()) / (1000*60*60*24))
   - If daysUntil >= 30: return 0
   - Return Math.round(100 * (1 - daysUntil / 30))

3. **calculateGoalScore(topic, learningGoals)** - Goal alignment:
   - Exact match (case-insensitive): 100
   - Partial match (substring): 70
   - No match: 0
   - Apply deadline multiplier: <=7 days = 1.5x, <=30 days = 1.2x
   - Return max score across all goals

4. **scoreTopic(topic, profile, upcomingTests, learningGoals, weights?)** - Composite:
   - Calculate all three component scores
   - Composite = mastery*0.3 + urgency*0.4 + goals*0.3
   - Confidence: attempts === 0 -> 'low', < 10 -> 'medium', >= 10 -> 'high'
   - Generate Hebrew reasoning array based on scores

5. **generateRecommendations(scoredTopics, count = 5)** - Balanced selection:
   - Sort by composite score descending
   - Select 30% from weakness (masteryScore >= 60)
   - Select 40% from growth (masteryScore 30-60)
   - Select 30% from maintenance (masteryScore < 30)
   - Fill remaining with highest scored
   - Return sorted by score

6. **recordOverride(childId, familyId, parentId, topic, reason, customReason?)** - Firestore logging:
   - Create RecommendationOverride object
   - Add to 'recommendationOverrides' collection
   - Fire-and-forget pattern (swallow errors, log warning)

Follow existing service patterns:
- Use logger from '../lib'
- Use generateId from '../lib'
- Import db from '../firebaseConfig'
- Use try-catch with logger.error for recordOverride
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors. Verify exports: scoreTopic, generateRecommendations, recordOverride</verify>
  <done>recommendationService.ts exports working scoring algorithms that produce TopicScore and Recommendation arrays</done>
</task>

<task type="auto">
  <name>Task 3: Export recommendationService from services/index.ts</name>
  <files>services/index.ts</files>
  <action>
Add to services/index.ts after the Adaptive Quiz exports:

```typescript
// Recommendation Engine (Phase 3)
export {
  scoreTopic,
  generateRecommendations,
  recordOverride
} from './recommendationService';
```
  </action>
  <verify>Import test: `import { scoreTopic, generateRecommendations } from './services'` compiles</verify>
  <done>Recommendation service functions exported from services index</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. types.ts contains LearningGoal, TopicScore, Recommendation, OverrideReason interfaces
3. services/recommendationService.ts exports scoreTopic, generateRecommendations, recordOverride
4. services/index.ts re-exports recommendation functions
</verification>

<success_criteria>
- All recommendation types defined in types.ts
- scoreTopic produces 0-100 composite scores with Hebrew reasoning
- generateRecommendations returns 3-5 balanced recommendations
- recordOverride logs to Firestore (fire-and-forget)
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-recommendation-engine/03-01-SUMMARY.md`
</output>
